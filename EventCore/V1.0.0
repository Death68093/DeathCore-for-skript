function openSettings(plr: player):
    set {_settings} to a new chest inventory with 6 rows named "Event Settings - Home"
    set slot 10 of {_settings} to a gold ingot named "Tokens" with lore "Edit token settings"
    set slot 12 of {_settings} to a compass named "Event Start Settings" with lore "What to do with ""/startevent"" command"
    set slot 14 of {_settings} to a skeleton skull named "Dead Settings" with lore "Adjust permissions for dead players"
    set slot 16 of {_settings} to a diamond named "Event Settings" with lore "Settings during an event"
    open {_settings} to {_plr}

function checkPerm(plr: player, perm: string) :: boolean:
    if {_plr} has permission "%{_perm}%":
        return true
    else:
        return false

command /ec [<text>]:
    permission: dc.admin
    usage: /ec <settings|help>
    trigger:
        set {_arg1} to arg-1

        if {_arg1} is not set:
            openSettings(player)
            stop

        if {_arg1} is "settings":
            openSettings(player)
            stop

        if {_arg1} is "help":
            send "&6&lEvent Controller Help"
            send "&e/ec settings &7- Open event settings GUI"
            send "&e/ec help &7- Show this help menu"
            send ""
            send "&6&lEvent Commands"
            send "&e/setevent <name> &7- Set event name"
            send "&e/startevent &7- Start the event"
            send "&e/eventcooldown <minutes> &7- Event countdown"
            send "&e/timer <seconds> &7- Simple timer"
            send ""
            send "&6&lPlayer Control"
            send "&e/revive <player> &7- Revive a player"
            send "&e/reviveall &7- Revive everyone"
            send "&e/tpalive &7- TP alive players"
            send "&e/tpdead &7- TP dead players"
            send ""
            send "&6&lTokens"
            send "&e/addtoken <player> &7- Give a player 1 token"
            send "&e/remtoken <player> &7- Remove 1 token from a player"
            send "&e/usetoken &7- Request to use a revive token"
            stop

        send "&cUnknown subcommand. Use &e/ec help"


# Settings Handler
on inventory click:
    if name of event-inventory is "Event Settings - Home":
        cancel event

        if event-slot is 10:
            set {_tokens} to a new chest inventory with 5 rows named "Token Settings"
            if {server::settings::allowTokens} is true:
                set slot 10 of {_tokens} to a lime wool named "&cDisable Tokens" with lore "&aEnabled"
            else:
                set slot 10 of {_tokens} to a red wool named "&aEnable Tokens" with lore "&cDisabled"
            open {_tokens} to player

        else if event-slot is 12:
            set {_start} to a new chest inventory with 5 rows named "Event Start Settings"

            if {server::settings::start::clearInv} is true:
                set slot 10 of {_start} to a lime wool named "Disable Inventory Clear" with lore "&aClears inventories"
            else:
                set slot 10 of {_start} to a red wool named "Enable Inventory Clear" with lore "&cKeeps inventories"

            if {server::settings::start::revivePlayers} is true:
                set slot 12 of {_start} to a lime wool named "Disable Revivals" with lore "&aRevives all players"
            else:
                set slot 12 of {_start} to a red wool named "Enable Revivals" with lore "&cNo auto revives"

            open {_start} to player

        else if event-slot is 14:
            set {_dead} to a new chest inventory with 5 rows named "Dead Settings"
            if {server::settings::allowSpectate} is true:
                set slot 10 of {_dead} to a lime wool named "Disable Spectating" with lore "&aSpectating allowed"
            else:
                set slot 10 of {_dead} to a red wool named "Enable Spectating" with lore "&cSpectating blocked"
            open {_dead} to player

        else if event-slot is 16:
            set {_basic} to a new chest inventory with 5 rows named "Event Settings"

            if {server::settings::allowPVP} is true:
                set slot 10 of {_basic} to a lime wool named "Disable PVP" with lore "&aPVP enabled"
            else:
                set slot 10 of {_basic} to a red wool named "Enable PVP" with lore "&cPVP disabled"

            if {server::settings::allowPlace} is true:
                set slot 12 of {_basic} to a lime wool named "Disable Block Placing" with lore "&aPlacing allowed"
            else:
                set slot 12 of {_basic} to a red wool named "Enable Block Placing" with lore "&cPlacing blocked"

            if {server::settings::allowBreak} is true:
                set slot 14 of {_basic} to a lime wool named "Disable Block Breaking" with lore "&aBreaking allowed"
            else:
                set slot 14 of {_basic} to a red wool named "Enable Block Breaking" with lore "&cBreaking blocked"

            if {server::settings::allowStorage} is true:
                set slot 16 of {_basic} to a lime wool named "Disable Storage Access" with lore "&aStorage allowed"
            else:
                set slot 16 of {_basic} to a red wool named "Enable Storage Access" with lore "&cStorage blocked"

            open {_basic} to player



    else if name of event-inventory is "Token Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::allowTokens} is true:
                set {server::settings::allowTokens} to false
            else:
                set {server::settings::allowTokens} to true
            make player execute command "ec settings"

    else if name of event-inventory is "Event Start Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::start::clearInv} is true:
                set {server::settings::start::clearInv} to false
            else:
                set {server::settings::start::clearInv} to true
            make player execute command "ec settings"

        else if event-slot is 12:
            if {server::settings::start::revivePlayers} is true:
                set {server::settings::start::revivePlayers} to false
            else:
                set {server::settings::start::revivePlayers} to true
            make player execute command "ec settings"
    else if name of event-inventory is "Dead Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::allowSpectate} is true:
                set {server::settings::allowSpectate} to false
            else:
                set {server::settings::allowSpectate} to true
            make player execute command "ec settings"
    else if name of event-inventory is "Event Settings":
        cancel event

        if event-slot is 10:
            if {server::settings::allowPVP} is true:
                set {server::settings::allowPVP} to false
            else:
                set {server::settings::allowPVP} to true
            make player execute command "ec settings"

        else if event-slot is 12:
            if {server::settings::allowPlace} is true:
                set {server::settings::allowPlace} to false
            else:
                set {server::settings::allowPlace} to true
            make player execute command "ec settings"

        else if event-slot is 14:
            if {server::settings::allowBreak} is true:
                set {server::settings::allowBreak} to false
            else:
                set {server::settings::allowBreak} to true
            make player execute command "ec settings"

        else if event-slot is 16:
            if {server::settings::allowStorage} is true:
                set {server::settings::allowStorage} to false
            else:
                set {server::settings::allowStorage} to true
            make player execute command "ec settings"




# Event Management
command /timer <number>:
    permission: dc.host.timer
    trigger:
        set {server::timer} to arg-1
        while {server::timer} > 0:
            broadcast "&e%{server::timer}%"
            remove 1 from {server::timer}
            wait for 1 second
            if {server::timer} is 0:
                broadcast "&2Timer Ended!"

command /eventcooldown <number>:
    permission: dc.host.eventcooldown
    trigger:
        set {server::event::cooldown} to arg-1
        if {server::event} is set:
            set {_event} to {server::event}
        else:
            set {_event} to "Event"
        broadcast "&2%{_event}% begins in &e%{server::event::cooldown}% &2minute(s)!"

        while {server::event::cooldown} > 0:
            wait 1 minute
            subtract 1 from {server::event::cooldown}

            if {server::event::cooldown} > 1:
                if mod({server::event::cooldown}, 5) = 0:
                    broadcast "&2%{_event}% begins in &e%{server::event::cooldown}% &2minutes!"

            if {server::event::cooldown} = 1:
                broadcast "&c%{_event}% begins in &e1 &cminute!"

        broadcast "&c%{_event}% begins in &e30 &cseconds!"
        wait 20 seconds

        loop 10 times:
            broadcast "&c%{_event}% begins in &e%11 - loop-number% &cseconds!"
            wait 1 second

        broadcast "&a%{_event}% has started!"


command /setevent <text>:
    permission: dc.host.setevent
    usage: /setevent <EVENT_NAME>
    description: Set a new event!
    trigger:
        set {_name} to arg-1
        set {server::event} to {_name}
        send "&2Set event to &e%{_name}%"
command /addhost <player>:
    permission: dc.admin.sethost
    description: Make a player a host (use /remhost to remove)
    trigger:
        set {_target} to arg-1
        if {server::event::hosts::*} doesn't contain {_target}:
            add {_target} to {server::event::hosts::*}
            broadcast "&2%{_target}% is now a host!"
        else:
            send "&c%{_target}% is already a host!"
command /remhost <player>:
    permission: dc.admin.sethost
    description: Make a player a host (use /remhost to remove)
    trigger:
        set {_target} to arg-1
        if {server::event::hosts::*} contains {_target}:
            remove {_target} from {server::event::hosts::*}
            broadcast "&c%{_target}% is no longer a host!"
        else:
            send "&c%{_target}% is not a host!"


command /startevent:
    permission: dc.host.startevent
    description: Start the event
    trigger:
        if {server::settings::start::clearInv} is true:
            loop all players:
                if {server::event::hosts} doesn't contain loop-value:
                    clear loop-value's inventory
                    clear helmet of loop-value
                    clear chestplate of loop-value
                    clear leggings of loop-value
                    clear boots of loop-value
        if {server::settings::start::revivePlayers} is true:
            make player execute command "reviveall"
# Permissions (Requires LuckPerms)
command /grantperm <player> <text>:
    permission: dc.admin.grantperm
    aliases: giveperm, addperm
    usage: grantperm <player> <permission>
    description: Grant a permission to a user (requires LuckPerms)
    trigger:
        set {_target} to arg-1
        set {_perm} to arg-2
        if plugin "LuckPerms" is enabled:
            execute CONSOLE command "lp user %{_target}% permission set %{_perm}% true"
            send "&2Added permission &e%{_perm}%&2 to &e%{_target}%"

        else:
            send "&cLuckPerms plugin is not installed/enabled! Please Install and enable LuckPerms to use this feature!"
command /revokeperm <player> <text>:
    permission: dc.admin.grantperm
    aliases: removeperm, remperm, takeperm
    usage: revokeperm <player> <permission>
    description: Removes a permission from a user (requires LuckPerms)
    trigger:
        set {_target} to arg-1
        set {_perm} to arg-2
        if plugin "LuckPerms" is enabled:
            execute CONSOLE command "lp user %{_target}% permission set %{_perm}% false"
            send "&2Removed permission &e%{_perm}%&2 from &e%{_target}%"
        else:
            send "&cLuckPerms plugin is not installed/enabled! Please Install and enable LuckPerms to use this feature!"



# Teleports
command /tpalive [<text>]:
    permission: dc.host.tp.alive
    description: Teleports all alive players to your location or a warp
    usage: /tpalive [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            loop {server::event::alive::*}:
                teleport loop-value to player
        else:
            loop {server::event::alive::*}:
                teleport loop-value to {server::warps::%{_warp}%}

command /tpdead [<text>]:
    permission: dc.host.tp.dead
    description: Teleports all dead players to your location
    usage: /tpalive [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            loop {server::event::dead::*}:
                teleport loop-value to player
        else:
            loop {server::event::dead::*}:
                teleport loop-value to {server::warps::%{_warp}%}

command /tpall [<text>]:
    permission: dc.host.tp.all
    description: Teleports all players to your location
    usage: /tpall [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            teleport players to player
        else:
            teleport players to {server::warps::%{_warp}%}




# Life Management (revive/eliminate)
command /reviveall:
    permission: dc.host.revive.all
    aliases: revall, resall, rezall
    description: Revive all players
    trigger:
        loop all players:
            add loop-value to {server::event::alive::*}
            remove loop-value from {server::event::dead::*}
            send "&2You have been revived!" to loop-value
        teleport players to player

command /revive <player>:
    permission: dc.host.permission.revive.player
    description: Revive a specific player
    trigger:
        set {_target} to arg-1
        add {_target} to {server::event::alive::*}
        remove {_target} from {server::event::dead::*}
        teleport {_target} to player
        send "&2You have been revived!" to {_target}




# Revive Token Management
command /addtoken <player>:
    permission: dc.host.token.addtoken
    description: Give a Revive token to a player
    trigger:
        set {_target} to arg-1
        add 1 to {server::event::%{_target}%::tokens}
        broadcast "&9%{_target}%&fHas &2Received &f1 revive token! They now have &e%{server::event::%{_target}%::tokens}%&f!"

command /remtoken <player>:
    permission: dc.host.token.remtoken
    aliases: removetoken
    description: Remove a Revive token from a player
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::tokens} < 1:
            send "&c%{_target}% doesn't have an tokens!"
            stop
        remove 1 from {server::event::%{_target}%::tokens}
        broadcast "&9%{_target}%&fHas &clost &f1 revive token! They now have &e%{server::event::%{_target}%::tokens}%&f!"

command /usetoken:
    description: Request a revive using 1 revive token
    cooldown: 1 minute
    trigger:
        if {server::settings::allowTokens} is true:
            if {server::event::%player%::tokens} > 0:
                loop {server::event::hosts::*}:
                    send "&e%player% &2is requesting to &euse a revive token!&2 Type &e""/accepttoken %player%"" &fto &2accept&f or &e""/denytoken %player%""&f to &cdeny" to loop-value
                send "&2Token request sent! Awaiting host response!"
                set {server::event::%player%::awaitingTokenConfirmation} to true
        else:
            send "&cTokens are disabled!" to player

command /accepttoken <player>:
    permission: dc.host.token.accepttoken
    description: Accept a user's token
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::awaitingTokenConfirmation} is true:
            send "&2You're token has been accepted!" to {_target}
            execute CONSOLE command "remtoken %{_target}%"
            send "&2You have accepted %{_target}%'s revive token!"
            set {server::event::%{_target}%::awaitingTokenConfirmation} to false
        else:
            send "&c%{_target}% isn't using a token!"
command /denytoken <player>:
    permission: dc.host.token.accepttoken
    aliases: declinetoken
    description: Deny a user's token
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::awaitingTokenConfirmation} is true:
            send "&cYou're token has been declined!!" to {_target}
            send "&cYou have denied %{_target}%'s revive token!"
            set {server::event::%{_target}%::awaitingTokenConfirmation} to false
        else:
            send "&c%{_target}% isn't using a token!"

            
# Warps
command /setspawn:
    permission: dc.host.setspawn
    description: Set the server spawn
    trigger:
        set {server::spawnpoint} to the player's location
        send "&2Set Spawnpoint to &e%{server::spawnpoint}%"

command /setwarp <text>:
    permission: dc.host.warps.setwarp
    aliases: addwarp, createwarp
    description: Create a warp
    usage: /setwarp <WARP_NAME>
    trigger:
        set {_warp} to arg-1
        set {server::warps::%{_warp}%} to the player's location
        send "&2Warp &e""%{_warp}%""&2 created at &e%{server::warps::%{_warp}%}%!"

command /delwarp <text>:
    permission: dc.host.warps.delwarp
    aliases: remwarp, deletewarp
    description: Delete a warp
    usage: /delwarp <WARP_NAME>
    trigger:
        set {_warp} to arg-1
        delete {server::warps::%{_warp}%}
        send "&2Warp &e""%{_warp}%""&2 Deleted!"
command /viewwarps:
    permission:dc.host.warps.viewwarps
    description: View all warps
    trigger:
        set {_i} to 1
        loop {server::warps::*}:
            send "&f%{_i}%. -&e %loop-index%"
            add 1 to {_i}

# Wins
command /addwin <player>:
    permission: dc.host.win.addwin
    description: Add a win to a player
    trigger:
        set {_target} to arg-1
        add 1 to {server::event::%{_target}%::wins}
        broadcast "&9%{_target}%&fHas &2Received &f1 Win! They now have &e%{server::event::%{_target}%::wins}%&f!"

command /remwin <player>:
    permission: dc.host.win.remwin
    aliases: removewin
    description: Remove a win from a player
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::wins} < 1:
            send "&c%{_target}% doesn't have an wins!"
            stop
        remove 1 from {server::event::%{_target}%::wins}
        broadcast "&9%{_target}%&fHas &clost &f1 win! They now have &e%{server::event::%{_target}%::wins}%&f!"


# Player Defaults
on join:
    if {server::spawnpoint} is set:
        teleport player to {server::spawnpoint}
    remove player from {server::event::alive::*}
    add player to {server::event::dead::*}

on death of player:
    remove victim from {server::event::alive::*}
    add victim to {server::event::dead::*}
    force victim to respawn

on quit:
    remove player from {server::event::alive::*}
    add player to {server::event::dead::*}

on respawn:
    if {server::spawnpoint} is set:
        teleport player to {server::spawnpoint}


# Other Player Commands
command /spectate:
    description: Spectate the game
    trigger:
        if {server::event::dead::*} contains player:
            if {server::settings::allowSpectate} is true:
                set gamemode of player to spectator
            else:
                send "&cSpectating is disabled"
        else:
            send "&cYou may only spectate after you have been eliminated!"



every second:
    if {server::settings::allowSpectate} is false:
        loop all players:
            if {server::event::hosts::*} doesn't contain loop-value:
                if gamemode of loop-value is spectator:
                    set gamemode of loop-value to survival
                    send "&cSpectating was disabled!" to loop-value
                    teleport loop-value to {server::spawnpoint}


on place:
    if {server::event::hosts::*} doesn't contain player:
        if {server::settings::allowPlace} isn't true:
            cancel event
            send "&cBlock Placing is disabled!"
   
on break:
    if {server::event::hosts::*} doesn't contain player:
        if {server::settings::allowBreak} isn't true:
            cancel event
            send "&cBlock Breaking is disabled!"

on rightclick on chest or furnace or brewing stand or ender chest or trapped chest:
    if {server::event::hosts::*} doesn't contain player:
        if {server::settings::allowStorage} isn't true:
            close player's inventory
            cancel event
            send "&cChests are disabled!"

on damage of player:
    if {server::settings::allowPVP} isn't true:
        if {server::event::hosts::*} doesn't contain victim:
            cancel event
            send "&cPVP is disabled!" to attacker

# Quick setting toggles:
command /pvp:
    permission: dc.host.toggle.pvp
    description: Toggle PVP during the event
    trigger:
        if {server::settings::allowPVP} is true:
            set {server::settings::allowPVP} to false
            broadcast "&cPVP has been &lDISABLED&c!"
        else:
            set {server::settings::allowPVP} to true
            broadcast "&aPVP has been &lENABLED&a!"

command /break:
    permission: dc.host.toggle.blockbreak
    description: Toggle block breaking during the event
    trigger:
        if {server::settings::allowBreak} is true:
            set {server::settings::allowBreak} to false
            broadcast "&cBlock breaking has been &lDISABLED&c!"
        else:
            set {server::settings::allowBreak} to true
            broadcast "&aBlock breaking has been &lENABLED&a!"

command /place:
    permission: dc.host.toggle.blockplace
    description: Toggle block placing during the event
    trigger:
        if {server::settings::allowPlace} is true:
            set {server::settings::allowPlace} to false
            broadcast "&cBlock placing has been &lDISABLED&c!"
        else:
            set {server::settings::allowPlace} to true
            broadcast "&aBlock placing has been &lENABLED&a!"

command /storage:
    permission: dc.host.toggle.storageaccess
    description: Toggle storage access (chests, furnaces, etc.)
    trigger:
        if {server::settings::allowStorage} is true:
            set {server::settings::allowStorage} to false
            broadcast "&cStorage access has been &lDISABLED&c!"
        else:
            set {server::settings::allowStorage} to true
            broadcast "&aStorage access has been &lENABLED&a!"
