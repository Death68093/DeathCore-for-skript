function openSettings(plr: player):
    set {_settings} to a new chest inventory with 6 rows named "Event Settings - Home"
    set slot 10 of {_settings} to a gold ingot named "Tokens" with lore "Edit token settings"
    set slot 12 of {_settings} to a compass named "Event Start Settings" with lore "What to do with ""/startevent"" command"
    set slot 14 of {_settings} to a skeleton skull named "Dead Settings" with lore "Adjust permissions for dead players"
    set slot 16 of {_settings} to a diamond named "Event Settings" with lore "Settings during an event"
    open {_settings} to {_plr}

function checkPerm(plr: player, perm: string) :: boolean:
    if {_plr} has permission "%{_perm}%":
        return true
    else:
        return false

command /ec [<text>]:
    permission: dc.admin
    usage: /ec <settings|help>
    trigger:
        set {_arg1} to arg-1

        if {_arg1} is not set:
            openSettings(player)
            stop

        if {_arg1} is "settings":
            openSettings(player)
            stop

        if {_arg1} is "help":
            send "&6&lEvent Controller Help"
            send "&e/ec settings &7- Open event settings GUI"
            send "&e/ec help &7- Show this help menu"
            send ""
            send "&6&lEvent Commands"
            send "&e/setevent <name> &7- Set event name"
            send "&e/startevent &7- Start the event"
            send "&e/eventcooldown <minutes> &7- Event countdown"
            send "&e/timer <seconds> &7- Simple timer"
            send ""
            send "&6&lPlayer Control"
            send "&e/revive <player> &7- Revive a player"
            send "&e/reviveall &7- Revive everyone"
            send "&e/tpalive &7- TP alive players"
            send "&e/tpdead &7- TP dead players"
            send ""
            send "&6&lTokens"
            send "&e/addtoken <player> &7- Give a player 1 token"
            send "&e/remtoken <player> &7- Remove 1 token from a player"
            send "&e/usetoken &7- Request to use a revive token"
            stop

        send "&cUnknown subcommand. Use &e/ec help"


# Settings Handler
on inventory click:
    if name of event-inventory is "Event Settings - Home":
        cancel event

        if event-slot is 10:
            set {_tokens} to a new chest inventory with 5 rows named "Token Settings"
            if {server::settings::allowTokens} is true:
                set slot 10 of {_tokens} to a lime wool named "&cDisable Tokens" with lore "&aEnabled"
            else:
                set slot 10 of {_tokens} to a red wool named "&aEnable Tokens" with lore "&cDisabled"
            open {_tokens} to player

        else if event-slot is 12:
            set {_start} to a new chest inventory with 5 rows named "Event Start Settings"

            if {server::settings::start::clearInv} is true:
                set slot 10 of {_start} to a lime wool named "Disable Inventory Clear" with lore "&aClears inventories"
            else:
                set slot 10 of {_start} to a red wool named "Enable Inventory Clear" with lore "&cKeeps inventories"

            if {server::settings::start::revivePlayers} is true:
                set slot 12 of {_start} to a lime wool named "Disable Revivals" with lore "&aRevives all players"
            else:
                set slot 12 of {_start} to a red wool named "Enable Revivals" with lore "&cNo auto revives"

            open {_start} to player

        else if event-slot is 14:
            set {_dead} to a new chest inventory with 5 rows named "Dead Settings"
            if {server::settings::allowSpectate} is true:
                set slot 10 of {_dead} to a lime wool named "Disable Spectating" with lore "&aSpectating allowed"
            else:
                set slot 10 of {_dead} to a red wool named "Enable Spectating" with lore "&cSpectating blocked"
            open {_dead} to player

        else if event-slot is 16:
            set {_basic} to a new chest inventory with 5 rows named "Event Settings"

            if {server::settings::pvp} is true:
                set slot 10 of {_basic} to a lime wool named "Disable PVP" with lore "&aPVP enabled"
            else:
                set slot 10 of {_basic} to a red wool named "Enable PVP" with lore "&cPVP disabled"

            if {server::settings::block_place} is true:
                set slot 12 of {_basic} to a lime wool named "Disable Block Placing" with lore "&aPlacing allowed"
            else:
                set slot 12 of {_basic} to a red wool named "Enable Block Placing" with lore "&cPlacing blocked"

            if {server::settings::block_break} is true:
                set slot 14 of {_basic} to a lime wool named "Disable Block Breaking" with lore "&aBreaking allowed"
            else:
                set slot 14 of {_basic} to a red wool named "Enable Block Breaking" with lore "&cBreaking blocked"

            if {server::settings::allowStorage} is true:
                set slot 16 of {_basic} to a lime wool named "Disable Storage Access" with lore "&aStorage allowed"
            else:
                set slot 16 of {_basic} to a red wool named "Enable Storage Access" with lore "&cStorage blocked"
            
            if {server::settings::autoClearFloor} is true:
                set slot 28 of {_basic} to a lime wool named "Enable Floor AutoClear" with lore "&aClears all blocks on floor"
            else:
                set slot 28 of {_basic} to a lime wool named "Disable Floor AutoClear" with lore "&cDoesn't clear blocks"

            open {_basic} to player



    else if name of event-inventory is "Token Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::allowTokens} is true:
                set {server::settings::allowTokens} to false
            else:
                set {server::settings::allowTokens} to true
            make player execute command "ec settings"

    else if name of event-inventory is "Event Start Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::start::clearInv} is true:
                set {server::settings::start::clearInv} to false
            else:
                set {server::settings::start::clearInv} to true
            make player execute command "ec settings"

        else if event-slot is 12:
            if {server::settings::start::revivePlayers} is true:
                set {server::settings::start::revivePlayers} to false
            else:
                set {server::settings::start::revivePlayers} to true
            make player execute command "ec settings"
    else if name of event-inventory is "Dead Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::allowSpectate} is true:
                set {server::settings::allowSpectate} to false
            else:
                set {server::settings::allowSpectate} to true
            make player execute command "ec settings"
    else if name of event-inventory is "Event Settings":
        cancel event

        if event-slot is 10:
            if {server::settings::pvp} is true:
                set {server::settings::pvp} to false
            else:
                set {server::settings::pvp} to true
            make player execute command "ec settings"

        else if event-slot is 12:
            if {server::settings::block_place} is true:
                set {server::settings::block_place} to false
            else:
                set {server::settings::block_place} to true
            make player execute command "ec settings"

        else if event-slot is 14:
            if {server::settings::block_break} is true:
                set {server::settings::block_break} to false
            else:
                set {server::settings::block_break} to true
            make player execute command "ec settings"

        else if event-slot is 16:
            if {server::settings::allowStorage} is true:
                set {server::settings::allowStorage} to false
            else:
                set {server::settings::allowStorage} to true
            make player execute command "ec settings"
        else if event-slot is 28:
            if {server::settings::autoClearFloor} is true:
                set {server::settings::autoClearFloor} to false
            else:
                set {server::settings::autoClearFloor} to true



# Event Management
command /timer <number>:
    permission: dc.host.timer
    trigger:
        set {server::timer} to arg-1
        while {server::timer} > 0:
            broadcast "&e%{server::timer}%"
            remove 1 from {server::timer}
            wait for 1 second
            if {server::timer} is 0:
                broadcast "&2Timer Ended!"

command /eventcooldown <number>:
    permission: dc.host.eventcooldown
    trigger:
        set {server::event::cooldown} to arg-1
        if {server::event} is set:
            set {_event} to {server::event}
        else:
            set {_event} to "Event"
        broadcast "&2%{_event}% begins in &e%{server::event::cooldown}% &2minute(s)!"

        while {server::event::cooldown} > 0:
            wait 1 minute
            subtract 1 from {server::event::cooldown}

            if {server::event::cooldown} > 1:
                if mod({server::event::cooldown}, 5) = 0:
                    broadcast "&2%{_event}% begins in &e%{server::event::cooldown}% &2minutes!"

            if {server::event::cooldown} = 1:
                broadcast "&c%{_event}% begins in &e1 &cminute!"

        broadcast "&c%{_event}% begins in &e30 &cseconds!"
        wait 20 seconds

        loop 10 times:
            broadcast "&c%{_event}% begins in &e%11 - loop-number% &cseconds!"
            wait 1 second

        broadcast "&a%{_event}% has started!"


command /setevent <text>:
    permission: dc.host.setevent
    usage: /setevent <EVENT_NAME>
    description: Set a new event!
    trigger:
        set {_name} to arg-1
        set {server::event} to {_name}
        send "&2Set event to &e%{_name}%"
command /addhost <player>:
    permission: dc.admin.sethost
    description: Make a player a host (use /remhost to remove)
    trigger:
        set {_target} to arg-1
        if {server::roles::hosts::*} doesn't contain {_target}:
            add {_target} to {server::roles::hosts::*}
            broadcast "&2%{_target}% is now a host!"
        else:
            send "&c%{_target}% is already a host!"
command /remhost <player>:
    permission: dc.admin.sethost
    description: Make a player a host (use /remhost to remove)
    trigger:
        set {_target} to arg-1
        if {server::roles::hosts::*} contains {_target}:
            remove {_target} from {server::roles::hosts::*}
            broadcast "&c%{_target}% is no longer a host!"
        else:
            send "&c%{_target}% is not a host!"


command /startevent:
    permission: dc.host.startevent
    description: Start the event
    trigger:
        if {server::settings::start::clearInv} is true:
            loop all players:
                if {server::event::hosts} doesn't contain loop-value:
                    clear loop-value's inventory
                    clear helmet of loop-value
                    clear chestplate of loop-value
                    clear leggings of loop-value
                    clear boots of loop-value
        if {server::settings::start::revivePlayers} is true:
            make player execute command "reviveall"
# Permissions (Requires LuckPerms)
command /grantperm <player> <text>:
    permission: dc.admin.grantperm
    aliases: giveperm, addperm
    usage: grantperm <player> <permission>
    description: Grant a permission to a user (requires LuckPerms)
    trigger:
        set {_target} to arg-1
        set {_perm} to arg-2
        if plugin "LuckPerms" is enabled:
            execute CONSOLE command "lp user %{_target}% permission set %{_perm}% true"
            send "&2Added permission &e%{_perm}%&2 to &e%{_target}%"

        else:
            send "&cLuckPerms plugin is not installed/enabled! Please Install and enable LuckPerms to use this feature!"
command /revokeperm <player> <text>:
    permission: dc.admin.grantperm
    aliases: removeperm, remperm, takeperm
    usage: revokeperm <player> <permission>
    description: Removes a permission from a user (requires LuckPerms)
    trigger:
        set {_target} to arg-1
        set {_perm} to arg-2
        if plugin "LuckPerms" is enabled:
            execute CONSOLE command "lp user %{_target}% permission set %{_perm}% false"
            send "&2Removed permission &e%{_perm}%&2 from &e%{_target}%"
        else:
            send "&cLuckPerms plugin is not installed/enabled! Please Install and enable LuckPerms to use this feature!"



# Teleports
command /tpalive [<text>]:
    permission: dc.host.tp.alive
    description: Teleports all alive players to your location or a warp
    usage: /tpalive [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            loop {server::event::alive::*}:
                teleport loop-value to player
        else:
            loop {server::event::alive::*}:
                teleport loop-value to {server::warps::%{_warp}%}

command /tpdead [<text>]:
    permission: dc.host.tp.dead
    description: Teleports all dead players to your location
    usage: /tpalive [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            loop {server::event::dead::*}:
                teleport loop-value to player
        else:
            loop {server::event::dead::*}:
                teleport loop-value to {server::warps::%{_warp}%}

command /tpall [<text>]:
    permission: dc.host.tp.all
    description: Teleports all players to your location
    usage: /tpall [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            teleport players to player
        else:
            teleport players to {server::warps::%{_warp}%}




# Life Management (revive/eliminate)
command /reviveall:
    permission: dc.host.revive.all
    aliases: revall, resall, rezall
    description: Revive all players
    trigger:
        loop all players:
            add loop-value to {server::event::alive::*}
            remove loop-value from {server::event::dead::*}
            send "&2You have been revived!" to loop-value
        teleport players to player

command /revive <player>:
    permission: dc.host.permission.revive.player
    description: Revive a specific player
    trigger:
        set {_target} to arg-1
        add {_target} to {server::event::alive::*}
        remove {_target} from {server::event::dead::*}
        teleport {_target} to player
        send "&2You have been revived!" to {_target}




# Revive Token Management
command /addtoken <player>:
    permission: dc.host.token.addtoken
    description: Give a Revive token to a player
    trigger:
        set {_target} to arg-1
        add 1 to {server::event::%{_target}%::tokens}
        broadcast "&9%{_target}%&fHas &2Received &f1 revive token! They now have &e%{server::event::%{_target}%::tokens}%&f!"

command /remtoken <player>:
    permission: dc.host.token.remtoken
    aliases: removetoken
    description: Remove a Revive token from a player
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::tokens} < 1:
            send "&c%{_target}% doesn't have an tokens!"
            stop
        remove 1 from {server::event::%{_target}%::tokens}
        broadcast "&9%{_target}%&fHas &clost &f1 revive token! They now have &e%{server::event::%{_target}%::tokens}%&f!"

command /usetoken:
    description: Request a revive using 1 revive token
    cooldown: 1 minute
    trigger:
        if {server::settings::allowTokens} is true:
            if {server::event::players::%uuid of player%::tokens} > 0:
                loop {server::roles::hosts::*}:
                    send "&e%player% &2is requesting to &euse a revive token!&2 Type &e""/accepttoken %player%"" &fto &2accept&f or &e""/denytoken %player%""&f to &cdeny" to loop-value
                send "&2Token request sent! Awaiting host response!"
                set {server::event::%player%::awaitingTokenConfirmation} to true
        else:
            send "&cTokens are disabled!" to player

command /accepttoken <player>:
    permission: dc.host.token.accepttoken
    description: Accept a user's token
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::awaitingTokenConfirmation} is true:
            send "&2You're token has been accepted!" to {_target}
            execute CONSOLE command "remtoken %{_target}%"
            send "&2You have accepted %{_target}%'s revive token!"
            set {server::event::%{_target}%::awaitingTokenConfirmation} to false
        else:
            send "&c%{_target}% isn't using a token!"
command /denytoken <player>:
    permission: dc.host.token.accepttoken
    aliases: declinetoken
    description: Deny a user's token
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::awaitingTokenConfirmation} is true:
            send "&cYou're token has been declined!!" to {_target}
            send "&cYou have denied %{_target}%'s revive token!"
            set {server::event::%{_target}%::awaitingTokenConfirmation} to false
        else:
            send "&c%{_target}% isn't using a token!"

            
# Warps
command /setspawn:
    permission: dc.host.setspawn
    description: Set the server spawn
    trigger:
        set {server::spawnpoint} to the player's location
        send "&2Set Spawnpoint to &e%{server::spawnpoint}%"

command /setwarp <text>:
    permission: dc.host.warps.setwarp
    aliases: addwarp, createwarp
    description: Create a warp
    usage: /setwarp <WARP_NAME>
    trigger:
        set {_warp} to arg-1
        set {server::warps::%{_warp}%} to the player's location
        send "&2Warp &e""%{_warp}%""&2 created at &e%{server::warps::%{_warp}%}%!"

command /delwarp <text>:
    permission: dc.host.warps.delwarp
    aliases: remwarp, deletewarp
    description: Delete a warp
    usage: /delwarp <WARP_NAME>
    trigger:
        set {_warp} to arg-1
        delete {server::warps::%{_warp}%}
        send "&2Warp &e""%{_warp}%""&2 Deleted!"
command /viewwarps:
    permission:dc.host.warps.viewwarps
    description: View all warps
    trigger:
        set {_i} to 1
        loop {server::warps::*}:
            send "&f%{_i}%. -&e %loop-index%"
            add 1 to {_i}

# Wins
command /addwin <player>:
    permission: dc.host.win.addwin
    description: Add a win to a player
    trigger:
        set {_target} to arg-1
        add 1 to {server::event::%{_target}%::wins}
        broadcast "&9%{_target}%&fHas &2Received &f1 Win! They now have &e%{server::event::%{_target}%::wins}%&f!"

command /remwin <player>:
    permission: dc.host.win.remwin
    aliases: removewin
    description: Remove a win from a player
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::wins} < 1:
            send "&c%{_target}% doesn't have an wins!"
            stop
        remove 1 from {server::event::%{_target}%::wins}
        broadcast "&9%{_target}%&fHas &clost &f1 win! They now have &e%{server::event::%{_target}%::wins}%&f!"


# Player Defaults
on join:
    if {server::spawnpoint} is set:
        teleport player to {server::spawnpoint}
    remove player from {server::event::alive::*}
    add player to {server::event::dead::*}

on death of player:
    remove victim from {server::event::alive::*}
    add victim to {server::event::dead::*}
    force victim to respawn

on quit:
    remove player from {server::event::alive::*}
    add player to {server::event::dead::*}

on respawn:
    if {server::spawnpoint} is set:
        teleport player to {server::spawnpoint}


# Other Player Commands
command /spectate:
    description: Spectate the game
    trigger:
        if {server::event::dead::*} contains player:
            if {server::settings::allowSpectate} is true:
                set gamemode of player to spectator
            else:
                send "&cSpectating is disabled"
        else:
            send "&cYou may only spectate after you have been eliminated!"



every second:
    if {server::settings::allowSpectate} is false:
        loop all players:
            if {server::roles::hosts::*} doesn't contain loop-value:
                if gamemode of loop-value is spectator:
                    set gamemode of loop-value to survival
                    send "&cSpectating was disabled!" to loop-value
                    teleport loop-value to {server::spawnpoint}


on place:
    if {server::roles::hosts::*} doesn't contain player:
        if {server::settings::block_place} isn't true:
            cancel event
            send "&cBlock Placing is disabled!"
   
on break:
    if {server::roles::hosts::*} doesn't contain player:
        if {server::settings::block_break} isn't true:
            cancel event
            send "&cBlock Breaking is disabled!"

on rightclick on chest or furnace or brewing stand or ender chest or trapped chest:
    if {server::roles::hosts::*} doesn't contain player:
        if {server::settings::allowStorage} isn't true:
            close player's inventory
            cancel event
            send "&cChests are disabled!"

on damage of player:
    if {server::settings::pvp} isn't true:
        if {server::roles::hosts::*} doesn't contain victim:
            cancel event
            send "&cPVP is disabled!" to attacker

# Quick setting toggles:
command /pvp:
    permission: dc.host.toggle.pvp
    description: Toggle PVP during the event
    trigger:
        if {server::settings::pvp} is true:
            set {server::settings::pvp} to false
            broadcast "&cPVP has been &lDISABLED&c!"
        else:
            set {server::settings::pvp} to true
            broadcast "&aPVP has been &lENABLED&a!"

command /break:
    permission: dc.host.toggle.blockbreak
    description: Toggle block breaking during the event
    trigger:
        if {server::settings::block_break} is true:
            set {server::settings::block_break} to false
            broadcast "&cBlock breaking has been &lDISABLED&c!"
        else:
            set {server::settings::block_break} to true
            broadcast "&aBlock breaking has been &lENABLED&a!"

command /place:
    permission: dc.host.toggle.blockplace
    description: Toggle block placing during the event
    trigger:
        if {server::settings::block_place} is true:
            set {server::settings::block_place} to false
            broadcast "&cBlock placing has been &lDISABLED&c!"
        else:
            set {server::settings::block_place} to true
            broadcast "&aBlock placing has been &lENABLED&a!"

command /storage:
    permission: dc.host.toggle.storageaccess
    description: Toggle storage access (chests, furnaces, etc.)
    trigger:
        if {server::settings::allowStorage} is true:
            set {server::settings::allowStorage} to false
            broadcast "&cStorage access has been &lDISABLED&c!"
        else:
            set {server::settings::allowStorage} to true
            broadcast "&aStorage access has been &lENABLED&a!"

# Arena Stuff
command /setcorner1:
    permission: dc.host.arena.setcorners
    description: Sets the Bottom left corner of your Arena
    trigger:
        set {server::arena::corner1} to the player's location
        send "&2Set Arena corner 1 to &e%{server::arena::corner1}%"

        if {server::arena::corner2} isn't set:
            send "&2Be sure to set the other corner with `/setcorner2`"
command /setcorner2:
    permission: dc.host.arena.setcorners
    description: Sets the Top Right corner of your Arena
    trigger:
        set {server::arena::corner2} to the player's location
        send "&2Set Arena Corner 2 to &e%{server::arena::corner2}%"

        if {server::arena::corner1} isn't set:
            send "&2Be sure to set the other corner with `/setcorner1`"
command /setfloor [<number>]:
    description: Set the arena floor
    usage: /setfloor [y]
    permission: dc.host.arena.setfloor
    trigger:
        set {_y} to arg-1
        if {_y} is set:
            set {server::arena::floor} to {_y}
        else:
            set {server::arena::floor} to the player's y-coordinate
command /setroof [<number>]:
    description: Set the arena roof
    usage: /setroof [y]
    permission: dc.host.arena.setroof
    trigger:
        set {_y} to arg-1
        if {_y} is set:
            set {server::arena::roof} to {_y}
        else:
            set {server::arena::roof} to the player's y-coordinate
command /cleararena:
    permission: dc.host.arena.clear
    aliases: resetarena
    description: Clear the arena (warning: bigger arenas may cause lag)
    trigger:
        if {server::arena::corner1} is set:
            if {server::arena::corner2} is set:
                set blocks within {server::arena::corner1} and {server::arena::corner2} to air
                send "&2Arena Cleared!"
            else:
                send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
        else:
            send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
command /dropanvils <number>:
    permission: dc.host.event.dropanvils
    usage: /dropanvils <percent>
    description: Drop anvils from the roof
    trigger:
        set {_per} to arg-1
        if {server::arena::corner1} is set:
            if {server::arena::corner2} is set:
                if {server::arena::roof} is set:
                    set {_x1} to the x-coordinate of {server::arena::corner1}
                    set {_z1} to the z-coordinate of {server::arena::corner1}
                    set {_x2} to the x-coordinate of {server::arena::corner2}
                    set {_z2} to the z-coordinate of {server::arena::corner2}
                    set {_y} to {server::arena::roof}

                    set {_loc1} to the location at {_x1}, {_y}, {_z1}
                    set {_loc2} to the location at {_x2}, {_y}, {_z2}
                    loop blocks within {_loc1} and {_loc2}:
                        set {_num} to a random integer between 0 and 100
                        if {_num} <= {_per}:
                            set loop-block to anvil
                else:
                    send "&cPlease set the arena floor with `/setfloor [y]`"
            else:
                send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
        else:
            send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
command /raiselava <number> [<number>]:
    permission: dc.host.raiselava
    description: Raise the lava
    usage: /raiselava <blocks> [delay_per_block]
    trigger:
        set {_blocks} to arg-1
        set {_delay} to arg-2
        if {_delay} isn't set:
            set {_delay} to 0
        if {server::arena::lava::y} isn't set:
            set {server::arena::lava::y} to {server::arena::floor}
        loop {_blocks} times:
            wait for {_delay} seconds
            set {_y} to {server::arena::lava::y}
            set {_x} to x-coordinate of {server::arena::corner1}
            set {_z} to z-coordinate of {server::arena::corner1}
            set {_x2} to x-coordinate of {server::arena::corner2}
            set {_z2} to z-coordinate of {server::arena::corner2}
            set {_loc1} to the location at {_x}, {_y}, {_z}
            set {_loc2} to the location at {_x2}, {_y}, {_z2}
            set blocks within {_loc1} and {_loc2} to lava
            send "&2Current Lava Level: Y - &e%{server::arena::lava::y}%"
            add 1 to {server::arena::lava::y}
command /resetlava [<boolean>]:
    permission: dc.host.resetlava
    description: Resets lava and optionally clears the arena
    usage: /resetlava [clearArena? (true/false)]
    trigger:
        set {_clear} to arg-1
        delete {server::arena::lava::y}
        if {_clear} is true:
            make player execute command "cleararena"
        send "&2Lava Reset!"

function clearFloor():
    if {server::arena::corner1} is set:
        if {server::arena::corner2} is set:
            if {server::arena::floor} is set:
                set {_y} to {server::arena::floor}
                set {_x} to x-coordinate of {server::arena::corner1}
                set {_z} to z-coordinate of {server::arena::corner1}
                set {_x2} to x-coordinate of {server::arena::corner2}
                set {_z2} to z-coordinate of {server::arena::corner2}
                set {_loc1} to the location at {_x}, {_y}, {_z}
                set {_loc2} to the location at {_x2}, {_y}, {_z2}
                loop blocks within {_loc1} and {_loc2}:
                    set loop-block to air
                    wait 1 tick


every 3 seconds:
    if {server::settings::autoClearFloor} is true:
        clearFloor()

command /gms:
    permission: dc.gamemodes.survival
    description: Switch to survival mode
    trigger:
        set the player's gamemode to survival

command /gmc:
    permission: dc.gamemodes.creative
    description: Switch to creative mode
    trigger:
        set the player's gamemode to creative

command /gmsp:
    permission: dc.gamemodes.spectator
    description: Switch to spectator mode
    trigger:
        set the player's gamemode to spectator

command /gma:
    permission: dc.gamemodes.adventure
    description: Switch to adventure mode
    trigger:
        set the player's gamemode to adventure

command /heal <player>:
    permission: dc.host.heal.player
    description: Heal a player
    trigger:
        set {_p} to arg-1
        set health of {_p} to {_p}'s max health
        send "&2You have been healed!" to {_p}
        send "&2You healed &e%{_p}%&2!"

command /healall:
    permission:dc.host.heal.all
    description: Heal all players
    trigger:
        loop all players:
            make player execute command "heal %loop-value%"
command /healdead:
    permission:dc.host.heal.dead
    description: Heal dead players
    trigger:
        loop {server::event::dead::*}:
            make player execute command "heal %loop-value%"
command /healalive:
    permission:dc.host.heal.alive
    description: Heal alive players
    trigger:
        loop {server::event::alive::*}:
            make player execute command "heal %loop-value%"
command /kill <player>:
    permission: dc.host.kill.player
    description: Kill a player
    trigger:
        set {_p} to arg-1
        kill {_p}
command /killall:
    permission: dc.host.kill.all
    description: Kill everyone (except for hosts)
    trigger:
        loop all players:
            if {server::roles::hosts::*} doesn't contain loop-value:
                kill loop-value
command /killdead:
    permission: dc.host.kill.dead
    description: Kill dead players
    trigger:
        loop {server::event::dead::*}:
            if {server::roles::hosts::*} doesn't contain loop-value:
                kill loop-value
command /killalive:
    permission: dc.host.kill.alive
    description: Kill alive players
    trigger:
        loop {server::event::alive::*}:
            if {server::roles::hosts::*} doesn't contain loop-value:
                kill loop-value
