function openSettings(plr: player):
    set {_settings} to a new chest inventory with 6 rows named "Event Settings - Home"
    set slot 10 of {_settings} to a gold ingot named "Tokens" with lore "Edit token settings"
    set slot 12 of {_settings} to a compass named "Event Start Settings" with lore "What to do with ""/startevent"" command"
    set slot 14 of {_settings} to a skeleton skull named "Dead Settings" with lore "Adjust permissions for dead players"
    set slot 16 of {_settings} to a diamond named "Event Settings" with lore "Settings during an event"
    open {_settings} to {_plr}

function checkPerm(plr: player, perm: string) :: boolean:
    if {_plr} has permission "%{_perm}%":
        return true
    else:
        return false

command /ec [<text>]:
    permission: dc.admin
    usage: /ec <settings|help>
    trigger:
        set {_arg1} to arg-1

        if {_arg1} is not set:
            openSettings(player)
            stop

        if {_arg1} is "settings":
            openSettings(player)
            stop

        if {_arg1} is "help":
            send "&6&lEvent Controller Help"
            send "&e/ec settings &7- Open event settings GUI"
            send "&e/ec help &7- Show this help menu"
            send ""
            send "&6&lEvent Commands"
            send "&e/setevent <name> &7- Set event name"
            send "&e/startevent &7- Start the event"
            send "&e/eventcooldown <minutes> &7- Event countdown"
            send "&e/timer <seconds> &7- Simple timer"
            send ""
            send "&6&lPlayer Control"
            send "&e/revive <player> &7- Revive a player"
            send "&e/reviveall &7- Revive everyone"
            send "&e/tpalive &7- TP alive players"
            send "&e/tpdead &7- TP dead players"
            send ""
            send "&6&lTokens"
            send "&e/addtoken <player> &7- Give a player 1 token"
            send "&e/remtoken <player> &7- Remove 1 token from a player"
            send "&e/usetoken &7- Request to use a revive token"
            stop

        send "&cUnknown subcommand. Use &e/ec help"
function openHostPage(page: number, player: player):
    if {_page} is 0:
        openSettings({_player})
    else if {_page} is 1:
        set {_tokens} to a new chest inventory with 5 rows named "Token Settings"
        if {server::settings::allowTokens} is true:
            set slot 10 of {_tokens} to a lime wool named "&cDisable Tokens" with lore "&aEnabled"
        else:
            set slot 10 of {_tokens} to a red wool named "&aEnable Tokens" with lore "&cDisabled"
        open {_tokens} to {_player}
    else if {_page} is 2:
        set {_start} to a new chest inventory with 5 rows named "Event Start Settings"

        if {server::settings::start::clearInv} is true:
            set slot 10 of {_start} to a lime wool named "Disable Inventory Clear" with lore "&aClears inventories"
        else:
            set slot 10 of {_start} to a red wool named "Enable Inventory Clear" with lore "&cKeeps inventories"

        if {server::settings::start::revivePlayers} is true:
            set slot 12 of {_start} to a lime wool named "Disable Revivals" with lore "&aRevives all players"
        else:
            set slot 12 of {_start} to a red wool named "Enable Revivals" with lore "&cNo auto revives"

        open {_start} to {_player}
    else if {_page} is 3:
        set {_dead} to a new chest inventory with 5 rows named "Dead Settings"
        if {server::settings::allowSpectate} is true:
            set slot 10 of {_dead} to a lime wool named "Disable Spectating" with lore "&aSpectating allowed"
        else:
            set slot 10 of {_dead} to a red wool named "Enable Spectating" with lore "&cSpectating blocked"
        open {_dead} to {_player}
    else if {_page} is 4:
        set {_basic} to a new chest inventory with 5 rows named "Event Settings"

        if {server::settings::pvp} is true:
            set slot 10 of {_basic} to a lime wool named "Disable PVP" with lore "&aPVP enabled"
        else:
            set slot 10 of {_basic} to a red wool named "Enable PVP" with lore "&cPVP disabled"

        if {server::settings::block_place} is true:
            set slot 12 of {_basic} to a lime wool named "Disable Block Placing" with lore "&aPlacing allowed"
        else:
            set slot 12 of {_basic} to a red wool named "Enable Block Placing" with lore "&cPlacing blocked"

        if {server::settings::block_break} is true:
            set slot 14 of {_basic} to a lime wool named "Disable Block Breaking" with lore "&aBreaking allowed"
        else:
            set slot 14 of {_basic} to a red wool named "Enable Block Breaking" with lore "&cBreaking blocked"

        if {server::settings::allowStorage} is true:
            set slot 16 of {_basic} to a lime wool named "Disable Storage Access" with lore "&aStorage allowed"
        else:
            set slot 16 of {_basic} to a red wool named "Enable Storage Access" with lore "&cStorage blocked"
        
        if {server::settings::autoClearFloor} is true:
            set slot 28 of {_basic} to a lime wool named "Enable Floor AutoClear" with lore "&aClears all blocks on floor"
        else:
            set slot 28 of {_basic} to a red wool named "Disable Floor AutoClear" with lore "&cDoesn't clear blocks"

        if {server::settings::allow_teams} is true:
            set slot 30 of {_basic} to a lime wool named "Enable Teams" with lore "&aPlayers may switch teams!"
        else:
            set slot 30 of {_basic} to a red wool named "Disable Teams" with lore "&cPlayers cannot switch teams!"
        open {_basic} to {_player}

# Settings Handler
on inventory click:
    if name of event-inventory is "Event Settings - Home":
        cancel event

        if event-slot is 10:
            openHostPage(1, player)

        else if event-slot is 12:
            openHostPage(2, player)

        else if event-slot is 14:
            openHostPage(3, player)

        else if event-slot is 16:
            openHostPage(4, player)

    else if name of event-inventory is "Token Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::allowTokens} is true:
                set {server::settings::allowTokens} to false
                broadcast "&2Token are now &e&lDISABLED"
            else:
                set {server::settings::allowTokens} to true
                broadcast "&2Token are now &e&lENABLED"
            openHostPage(1, player)

    else if name of event-inventory is "Event Start Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::start::clearInv} is true:
                set {server::settings::start::clearInv} to false
                broadcast "&2Inventory Clear on Event Start is now &e&lDISABLED"
            else:
                set {server::settings::start::clearInv} to true
                broadcast "&2Inventory Clear on Event Start is now &e&lENABLED"
            openHostPage(2, player)

        else if event-slot is 12:
            if {server::settings::start::revivePlayers} is true:
                set {server::settings::start::revivePlayers} to false
                broadcast "&2Auto Revive on Event Start is now &e&lDISABLED"
            else:
                set {server::settings::start::revivePlayers} to true
                broadcast "&2Auto Revive on Event Start is now &e&lENABLED"
            openHostPage(2, player)

    else if name of event-inventory is "Dead Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::allowSpectate} is true:
                set {server::settings::allowSpectate} to false
                broadcast "&2Spectating for dead players is now &e&lDISABLED"
            else:
                set {server::settings::allowSpectate} to true
                broadcast "&2Spectating for dead players is now &e&lENABLED"
            openHostPage(3, player)

    else if name of event-inventory is "Event Settings":
        cancel event
        if event-slot is 10:
            if {server::settings::pvp} is true:
                set {server::settings::pvp} to false
                broadcast "&2PVP is now &e&lDISABLED"
            else:
                set {server::settings::pvp} to true
                broadcast "&2PVP is now &e&lENABLED"
            openHostPage(4, player)

        else if event-slot is 12:
            if {server::settings::block_place} is true:
                set {server::settings::block_place} to false
                broadcast "&2Block Placing is now &e&lDISABLED"
            else:
                set {server::settings::block_place} to true
                broadcast "&2Block Placing is now &e&lENABLED"
            openHostPage(4, player)

        else if event-slot is 14:
            if {server::settings::block_break} is true:
                set {server::settings::block_break} to false
                broadcast "&2Block Breaking is now &e&lDISABLED"
            else:
                set {server::settings::block_break} to true
                broadcast "&2Block Breaking is now &e&lENABLED"
            openHostPage(4, player)

        else if event-slot is 16:
            if {server::settings::allowStorage} is true:
                set {server::settings::allowStorage} to false
                broadcast "&2Storage Access is now &e&lDISABLED"
            else:
                set {server::settings::allowStorage} to true
                broadcast "&2Storage Access is now &e&lENABLED"
            openHostPage(4, player)

        else if event-slot is 28:
            if {server::settings::autoClearFloor} is true:
                set {server::settings::autoClearFloor} to false
                broadcast "&2Floor AutoClear is now &e&lDISABLED"
            else:
                set {server::settings::autoClearFloor} to true
                broadcast "&2Floor AutoClear is now &e&lENABLED"
            openHostPage(4, player)

        else if event-slot is 30:
            make player execute command "toggleteams"




# Event Management
command /timer <number>:
    permission: dc.host.timer
    trigger:
        set {server::timer} to arg-1
        while {server::timer} > 0:
            broadcast "&e%{server::timer}%"
            remove 1 from {server::timer}
            wait for 1 second
            if {server::timer} is 0:
                broadcast "&2Timer Ended!"

command /eventcooldown <number>:
    permission: dc.host.eventcooldown
    trigger:
        set {server::event::cooldown} to arg-1
        if {server::event} is set:
            set {_event} to {server::event}
        else:
            set {_event} to "Event"
        broadcast "&2%{_event}% begins in &e%{server::event::cooldown}% &2minute(s)!"

        while {server::event::cooldown} > 0:
            wait 1 minute
            subtract 1 from {server::event::cooldown}

            if {server::event::cooldown} > 1:
                if mod({server::event::cooldown}, 5) = 0:
                    broadcast "&2%{_event}% begins in &e%{server::event::cooldown}% &2minutes!"

            if {server::event::cooldown} = 1:
                broadcast "&c%{_event}% begins in &e1 &cminute!"

        broadcast "&c%{_event}% begins in &e30 &cseconds!"
        wait 20 seconds

        loop 10 times:
            broadcast "&c%{_event}% begins in &e%11 - loop-number% &cseconds!"
            wait 1 second

        broadcast "&a%{_event}% has started!"


command /setevent <text>:
    permission: dc.host.setevent
    usage: /setevent <EVENT_NAME>
    description: Set a new event!
    trigger:
        set {_name} to arg-1
        set {server::event} to {_name}
        send "&2Set event to &e%{_name}%"
command /addhost <player>:
    permission: dc.admin.sethost
    description: Make a player a host (use /remhost to remove)
    trigger:
        set {_target} to arg-1
        if {server::roles::hosts::*} doesn't contain {_target}:
            add {_target} to {server::roles::hosts::*}
            broadcast "&2%{_target}% is now a host!"
        else:
            send "&c%{_target}% is already a host!"
command /remhost <player>:
    permission: dc.admin.sethost
    description: Make a player a host (use /remhost to remove)
    trigger:
        set {_target} to arg-1
        if {server::roles::hosts::*} contains {_target}:
            remove {_target} from {server::roles::hosts::*}
            broadcast "&c%{_target}% is no longer a host!"
        else:
            send "&c%{_target}% is not a host!"


command /startevent:
    permission: dc.host.startevent
    description: Start the event
    trigger:
        if {server::settings::start::clearInv} is true:
            loop all players:
                if {server::event::hosts} doesn't contain loop-value:
                    clear loop-value's inventory
                    clear helmet of loop-value
                    clear chestplate of loop-value
                    clear leggings of loop-value
                    clear boots of loop-value
        if {server::settings::start::revivePlayers} is true:
            make player execute command "reviveall"
# Permissions (Requires LuckPerms)
command /grantperm <player> <text>:
    permission: dc.admin.grantperm
    aliases: giveperm, addperm
    usage: grantperm <player> <permission>
    description: Grant a permission to a user (requires LuckPerms)
    trigger:
        set {_target} to arg-1
        set {_perm} to arg-2
        if plugin "LuckPerms" is enabled:
            execute CONSOLE command "lp user %{_target}% permission set %{_perm}% true"
            send "&2Added permission &e%{_perm}%&2 to &e%{_target}%"

        else:
            send "&cLuckPerms plugin is not installed/enabled! Please Install and enable LuckPerms to use this feature!"
command /revokeperm <player> <text>:
    permission: dc.admin.grantperm
    aliases: removeperm, remperm, takeperm
    usage: revokeperm <player> <permission>
    description: Removes a permission from a user (requires LuckPerms)
    trigger:
        set {_target} to arg-1
        set {_perm} to arg-2
        if plugin "LuckPerms" is enabled:
            execute CONSOLE command "lp user %{_target}% permission set %{_perm}% false"
            send "&2Removed permission &e%{_perm}%&2 from &e%{_target}%"
        else:
            send "&cLuckPerms plugin is not installed/enabled! Please Install and enable LuckPerms to use this feature!"



# Teleports
command /tpalive [<text>]:
    permission: dc.host.tp.alive
    description: Teleports all alive players to your location or a warp
    usage: /tpalive [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            loop {server::event::alive::*}:
                teleport loop-value to player
        else:
            loop {server::event::alive::*}:
                teleport loop-value to {server::warps::%{_warp}%}

command /tpdead [<text>]:
    permission: dc.host.tp.dead
    description: Teleports all dead players to your location
    usage: /tpalive [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            loop {server::event::dead::*}:
                teleport loop-value to player
        else:
            loop {server::event::dead::*}:
                teleport loop-value to {server::warps::%{_warp}%}

command /tpall [<text>]:
    permission: dc.host.tp.all
    description: Teleports all players to your location
    usage: /tpall [WARP_NAME]
    trigger:
        set {_warp} to arg-1
        if {_warp} isn't set:
            teleport players to player
        else:
            teleport players to {server::warps::%{_warp}%}




# Life Management (revive/eliminate)
command /reviveall:
    permission: dc.host.revive.all
    aliases: revall, resall, rezall
    description: Revive all players
    trigger:
        loop all players:
            add loop-value to {server::event::alive::*}
            remove loop-value from {server::event::dead::*}
            send "&2You have been revived!" to loop-value
        teleport players to player

command /revive <player>:
    permission: dc.host.permission.revive.player
    description: Revive a specific player
    trigger:
        set {_target} to arg-1
        add {_target} to {server::event::alive::*}
        remove {_target} from {server::event::dead::*}
        teleport {_target} to player
        send "&2You have been revived!" to {_target}




# Revive Token Management
command /addtoken <player>:
    permission: dc.host.token.addtoken
    description: Give a Revive token to a player
    trigger:
        set {_target} to arg-1
        add 1 to {server::event::%{_target}%::tokens}
        broadcast "&9%{_target}%&fHas &2Received &f1 revive token! They now have &e%{server::event::%{_target}%::tokens}%&f!"

command /remtoken <player>:
    permission: dc.host.token.remtoken
    aliases: removetoken
    description: Remove a Revive token from a player
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::tokens} < 1:
            send "&c%{_target}% doesn't have an tokens!"
            stop
        remove 1 from {server::event::%{_target}%::tokens}
        broadcast "&9%{_target}%&fHas &clost &f1 revive token! They now have &e%{server::event::%{_target}%::tokens}%&f!"

command /usetoken:
    description: Request a revive using 1 revive token
    cooldown: 1 minute
    trigger:
        if {server::settings::allowTokens} is true:
            if {server::event::players::%uuid of player%::tokens} > 0:
                loop {server::roles::hosts::*}:
                    send "&e%player% &2is requesting to &euse a revive token!&2 Type &e""/accepttoken %player%"" &fto &2accept&f or &e""/denytoken %player%""&f to &cdeny" to loop-value
                send "&2Token request sent! Awaiting host response!"
                set {server::event::%player%::awaitingTokenConfirmation} to true
        else:
            send "&cTokens are disabled!" to player

command /accepttoken <player>:
    permission: dc.host.token.accepttoken
    description: Accept a user's token
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::awaitingTokenConfirmation} is true:
            send "&2You're token has been accepted!" to {_target}
            execute CONSOLE command "remtoken %{_target}%"
            send "&2You have accepted %{_target}%'s revive token!"
            set {server::event::%{_target}%::awaitingTokenConfirmation} to false
        else:
            send "&c%{_target}% isn't using a token!"
command /denytoken <player>:
    permission: dc.host.token.accepttoken
    aliases: declinetoken
    description: Deny a user's token
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::awaitingTokenConfirmation} is true:
            send "&cYou're token has been declined!!" to {_target}
            send "&cYou have denied %{_target}%'s revive token!"
            set {server::event::%{_target}%::awaitingTokenConfirmation} to false
        else:
            send "&c%{_target}% isn't using a token!"

            
# Warps
command /setspawn:
    permission: dc.host.setspawn
    description: Set the server spawn
    trigger:
        set {server::spawnpoint} to the player's location
        send "&2Set Spawnpoint to &e%{server::spawnpoint}%"

command /setwarp <text>:
    permission: dc.host.warps.setwarp
    aliases: addwarp, createwarp
    description: Create a warp
    usage: /setwarp <WARP_NAME>
    trigger:
        set {_warp} to arg-1
        set {server::warps::%{_warp}%} to the player's location
        send "&2Warp &e""%{_warp}%""&2 created at &e%{server::warps::%{_warp}%}%!"

command /delwarp <text>:
    permission: dc.host.warps.delwarp
    aliases: remwarp, deletewarp
    description: Delete a warp
    usage: /delwarp <WARP_NAME>
    trigger:
        set {_warp} to arg-1
        delete {server::warps::%{_warp}%}
        send "&2Warp &e""%{_warp}%""&2 Deleted!"
command /viewwarps:
    permission:dc.host.warps.viewwarps
    description: View all warps
    trigger:
        set {_i} to 1
        loop {server::warps::*}:
            send "&f%{_i}%. -&e %loop-index%"
            add 1 to {_i}

# Wins
command /addwin <player>:
    permission: dc.host.win.addwin
    description: Add a win to a player
    trigger:
        set {_target} to arg-1
        add 1 to {server::event::%{_target}%::wins}
        broadcast "&9%{_target}%&fHas &2Received &f1 Win! They now have &e%{server::event::%{_target}%::wins}%&f!"

command /remwin <player>:
    permission: dc.host.win.remwin
    aliases: removewin
    description: Remove a win from a player
    trigger:
        set {_target} to arg-1
        if {server::event::%{_target}%::wins} < 1:
            send "&c%{_target}% doesn't have an wins!"
            stop
        remove 1 from {server::event::%{_target}%::wins}
        broadcast "&9%{_target}%&fHas &clost &f1 win! They now have &e%{server::event::%{_target}%::wins}%&f!"


# Player Defaults
on join:
    if {server::spawnpoint} is set:
        teleport player to {server::spawnpoint}
    remove player from {server::event::alive::*}
    add player to {server::event::dead::*}

on death of player:
    remove victim from {server::event::alive::*}
    add victim to {server::event::dead::*}
    force victim to respawn

on quit:
    remove player from {server::event::alive::*}
    add player to {server::event::dead::*}

on respawn:
    if {server::spawnpoint} is set:
        teleport player to {server::spawnpoint}


# Other Player Commands
command /spectate:
    description: Spectate the game
    trigger:
        if {server::event::dead::*} contains player:
            if {server::settings::allowSpectate} is true:
                if gamemode of player isn't spectator:
                    set gamemode of player to spectator
                else:
                    set gamemode of player to survival
                    teleport player to {server::spawnpoint}
            else:
                send "&cSpectating is disabled"
        else:
            send "&cYou may only spectate after you have been eliminated!"



every second:
    if {server::settings::allowSpectate} is false:
        loop all players:
            if {server::roles::hosts::*} doesn't contain loop-value:
                if gamemode of loop-value is spectator:
                    set gamemode of loop-value to survival
                    send "&cSpectating was disabled!" to loop-value
                    teleport loop-value to {server::spawnpoint}


on place:
    if {server::roles::hosts::*} doesn't contain player:
        if {server::settings::block_place} isn't true:
            cancel event
            send "&cBlock Placing is disabled!"
   
on break:
    if {server::roles::hosts::*} doesn't contain player:
        if {server::settings::block_break} isn't true:
            cancel event
            send "&cBlock Breaking is disabled!"

on rightclick on chest or furnace or brewing stand or ender chest or trapped chest:
    if {server::roles::hosts::*} doesn't contain player:
        if {server::settings::allowStorage} isn't true:
            close player's inventory
            cancel event
            send "&cChests are disabled!"

on damage of player:
    if {server::settings::pvp} isn't true:
        if {server::roles::hosts::*} doesn't contain victim:
            cancel event
            send "&cPVP is disabled!" to attacker

# Quick setting toggles:
command /pvp:
    permission: dc.host.toggle.pvp
    description: Toggle PVP during the event
    trigger:
        if {server::settings::pvp} is true:
            set {server::settings::pvp} to false
            broadcast "&cPVP has been &lDISABLED&c!"
        else:
            set {server::settings::pvp} to true
            broadcast "&aPVP has been &lENABLED&a!"

command /break:
    permission: dc.host.toggle.blockbreak
    description: Toggle block breaking during the event
    trigger:
        if {server::settings::block_break} is true:
            set {server::settings::block_break} to false
            broadcast "&cBlock breaking has been &lDISABLED&c!"
        else:
            set {server::settings::block_break} to true
            broadcast "&aBlock breaking has been &lENABLED&a!"

command /place:
    permission: dc.host.toggle.blockplace
    description: Toggle block placing during the event
    trigger:
        if {server::settings::block_place} is true:
            set {server::settings::block_place} to false
            broadcast "&cBlock placing has been &lDISABLED&c!"
        else:
            set {server::settings::block_place} to true
            broadcast "&aBlock placing has been &lENABLED&a!"

command /storage:
    permission: dc.host.toggle.storageaccess
    description: Toggle storage access (chests, furnaces, etc.)
    trigger:
        if {server::settings::allowStorage} is true:
            set {server::settings::allowStorage} to false
            broadcast "&cStorage access has been &lDISABLED&c!"
        else:
            set {server::settings::allowStorage} to true
            broadcast "&aStorage access has been &lENABLED&a!"

# Arena Stuff
command /setcorner1:
    permission: dc.host.arena.setcorners
    description: Sets the Bottom left corner of your Arena
    trigger:
        set {server::arena::corner1} to the player's location
        send "&2Set Arena corner 1 to &e%{server::arena::corner1}%"

        if {server::arena::corner2} isn't set:
            send "&2Be sure to set the other corner with `/setcorner2`"
command /setcorner2:
    permission: dc.host.arena.setcorners
    description: Sets the Top Right corner of your Arena
    trigger:
        set {server::arena::corner2} to the player's location
        send "&2Set Arena Corner 2 to &e%{server::arena::corner2}%"

        if {server::arena::corner1} isn't set:
            send "&2Be sure to set the other corner with `/setcorner1`"
command /setfloor [<number>]:
    description: Set the arena floor
    usage: /setfloor [y]
    permission: dc.host.arena.setfloor
    trigger:
        set {_y} to arg-1
        if {_y} is set:
            set {server::arena::floor} to {_y}
        else:
            set {server::arena::floor} to the player's y-coordinate
command /setroof [<number>]:
    description: Set the arena roof
    usage: /setroof [y]
    permission: dc.host.arena.setroof
    trigger:
        set {_y} to arg-1
        if {_y} is set:
            set {server::arena::roof} to {_y}
        else:
            set {server::arena::roof} to the player's y-coordinate
command /cleararena:
    permission: dc.host.arena.clear
    aliases: resetarena
    description: Clear the arena (warning: bigger arenas may cause lag)
    trigger:
        if {server::arena::corner1} is set:
            if {server::arena::corner2} is set:
                set blocks within {server::arena::corner1} and {server::arena::corner2} to air
                send "&2Arena Cleared!"
            else:
                send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
        else:
            send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
command /dropanvils <number>:
    permission: dc.host.event.dropanvils
    usage: /dropanvils <percent>
    description: Drop anvils from the roof
    trigger:
        set {_per} to arg-1
        if {server::arena::corner1} is set:
            if {server::arena::corner2} is set:
                if {server::arena::roof} is set:
                    set {_x1} to the x-coordinate of {server::arena::corner1}
                    set {_z1} to the z-coordinate of {server::arena::corner1}
                    set {_x2} to the x-coordinate of {server::arena::corner2}
                    set {_z2} to the z-coordinate of {server::arena::corner2}
                    set {_y} to {server::arena::roof}

                    set {_loc1} to the location at {_x1}, {_y}, {_z1}
                    set {_loc2} to the location at {_x2}, {_y}, {_z2}
                    loop blocks within {_loc1} and {_loc2}:
                        set {_num} to a random integer between 0 and 100
                        if {_num} <= {_per}:
                            set loop-block to anvil
                else:
                    send "&cPlease set the arena floor with `/setfloor [y]`"
            else:
                send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
        else:
            send "&cPlease set the arena corners with `/setcorner1` and `/setcorner2`"
command /raiselava <number> [<number>]:
    permission: dc.host.raiselava
    description: Raise the lava
    usage: /raiselava <blocks> [delay_per_block]
    trigger:
        set {_blocks} to arg-1
        set {_delay} to arg-2
        if {_delay} isn't set:
            set {_delay} to 0
        if {server::arena::lava::y} isn't set:
            set {server::arena::lava::y} to {server::arena::floor}
        loop {_blocks} times:
            wait for {_delay} seconds
            set {_y} to {server::arena::lava::y}
            set {_x} to x-coordinate of {server::arena::corner1}
            set {_z} to z-coordinate of {server::arena::corner1}
            set {_x2} to x-coordinate of {server::arena::corner2}
            set {_z2} to z-coordinate of {server::arena::corner2}
            set {_loc1} to the location at {_x}, {_y}, {_z}
            set {_loc2} to the location at {_x2}, {_y}, {_z2}
            set blocks within {_loc1} and {_loc2} to lava
            send "&2Current Lava Level: Y - &e%{server::arena::lava::y}%"
            add 1 to {server::arena::lava::y}
command /resetlava [<boolean>]:
    permission: dc.host.resetlava
    description: Resets lava and optionally clears the arena
    usage: /resetlava [clearArena? (true/false)]
    trigger:
        set {_clear} to arg-1
        delete {server::arena::lava::y}
        if {_clear} is true:
            make player execute command "cleararena"
        send "&2Lava Reset!"

function clearFloor():
    if {server::arena::corner1} is set:
        if {server::arena::corner2} is set:
            if {server::arena::floor} is set:
                set {_y} to {server::arena::floor}
                set {_x} to x-coordinate of {server::arena::corner1}
                set {_z} to z-coordinate of {server::arena::corner1}
                set {_x2} to x-coordinate of {server::arena::corner2}
                set {_z2} to z-coordinate of {server::arena::corner2}
                set {_loc1} to the location at {_x}, {_y}, {_z}
                set {_loc2} to the location at {_x2}, {_y}, {_z2}
                loop blocks within {_loc1} and {_loc2}:
                    set loop-block to air
                    wait 1 tick


every 3 seconds:
    if {server::settings::autoClearFloor} is true:
        clearFloor()

command /gms:
    permission: dc.gamemodes.survival
    description: Switch to survival mode
    trigger:
        set the player's gamemode to survival

command /gmc:
    permission: dc.gamemodes.creative
    description: Switch to creative mode
    trigger:
        set the player's gamemode to creative

command /gmsp:
    permission: dc.gamemodes.spectator
    description: Switch to spectator mode
    trigger:
        set the player's gamemode to spectator

command /gma:
    permission: dc.gamemodes.adventure
    description: Switch to adventure mode
    trigger:
        set the player's gamemode to adventure

command /heal <player>:
    permission: dc.host.heal.player
    description: Heal a player
    trigger:
        set {_p} to arg-1
        set health of {_p} to {_p}'s max health
        send "&2You have been healed!" to {_p}
        send "&2You healed &e%{_p}%&2!"

command /healall:
    permission:dc.host.heal.all
    description: Heal all players
    trigger:
        loop all players:
            make player execute command "heal %loop-value%"
command /healdead:
    permission:dc.host.heal.dead
    description: Heal dead players
    trigger:
        loop {server::event::dead::*}:
            make player execute command "heal %loop-value%"
command /healalive:
    permission:dc.host.heal.alive
    description: Heal alive players
    trigger:
        loop {server::event::alive::*}:
            make player execute command "heal %loop-value%"
command /kill <player>:
    permission: dc.host.kill.player
    description: Kill a player
    trigger:
        set {_p} to arg-1
        kill {_p}
command /killall:
    permission: dc.host.kill.all
    description: Kill everyone (except for hosts)
    trigger:
        loop all players:
            if {server::roles::hosts::*} doesn't contain loop-value:
                kill loop-value
command /killdead:
    permission: dc.host.kill.dead
    description: Kill dead players
    trigger:
        loop {server::event::dead::*}:
            if {server::roles::hosts::*} doesn't contain loop-value:
                kill loop-value
command /killalive:
    permission: dc.host.kill.alive
    description: Kill alive players
    trigger:
        loop {server::event::alive::*}:
            if {server::roles::hosts::*} doesn't contain loop-value:
                kill loop-value

command /getcolor [<number>]:
    permission: dc.host.getcolor
    description: Get a color (E.g for 4 corners) (Colors: red, blue, green, yellow, purple, gold, grey, black, aqua, pink)
    usage: /getcolor [number of choices]
    trigger:
        set {_color::1} to "&cRED"
        set {_color::2} to "&1BLUE"
        set {_color::3} to "&2GREEN"
        set {_color::4} to "&eYELLOW"
        set {_color::5} to "&5PURPLE"
        set {_color::6} to "&6GOLD"
        set {_color::7} to "&7GREY"
        set {_color::8} to "&0BLACK"
        set {_color::9} to "&bAQUA"
        set {_color::10} to "&dPINK"

        set {_count} to arg
        if {_count} isn't set:
            set {_count} to 4

        set {_size} to {_colors::*}'s size
        if {_count} > {_size}:
            send "&cMax colors: 10"
            stop

        set {_i} to 1
        loop {_count} times:
            add {_color::%{_i}%} to {_choices::*}
            add 1 to {_i}

        loop 2 times:
            loop {_choices::*}:
                if loop-number-2 > {_count}:
                    continue
                send title "%loop-value-2%" to players for 5 ticks
                wait 5 ticks


        set {_chosen} to a random element out of {_choices::*}
        send "&aColor: %{_chosen}%" to player
        loop all players:
            send title "%{_chosen}%" to players for 3 seconds

command /rolldie [<text>]:
    description: Roll a die
    usage: /rolldie [broadcast? (true/false)]
    trigger:
        set {_broad} to arg-1
        set {_sides::*} to "‚öÄ", "‚öÅ", "‚öÇ", "‚öÉ", "‚öÑ", "‚öÖ"
        if {_broad} is true:
            if player has permission "dc.host.rolldie.broadcast":
                loop 2 times:
                    loop 6 times:
                        set {_side} to a random element out of {_sides::*}
                        send title "%{_side}%" to players for 5 ticks
                        wait 5 ticks
                set {_side} to a random element out of {_sides::*}
                send title "%{_side}%" to players for 3 seconds
                send "%{_side}%" to player
            else:
                send "&cYou don't have permission to broadcasts the die!"
        else:
            loop 2 times:
                loop 6 times:
                    set {_side} to a random element out of {_sides::*}
                    send title "%{_side}%" to player for 5 ticks
                    wait 5 ticks
            set {_side} to a random element out of {_sides::*}
            send title "%{_side}%" to player for 3 seconds
            send "%{_side}%" to player

# Teams
command /createteam <text> <color>:
    description: Create a team
    permission: dc.host.teams.createteam
    usage: /createteam <team_name> <team_color>
    aliases: addteam, setteam, maketeam
    trigger:
        set {_team} to arg-1
        set {_color} to arg-2
        set {server::teams::%{_team}%::name} to {_team}
        set {server::teams::%{_team}%::color} to {_color}
        send "&2Created team &e%{server::teams::%{_team}%::name}%&2 with color &e%{server::teams::%{_team}%::color}%"

command /deleteteam <text>:
    description: Delete a team
    permission: dc.host.teams.deleteteam
    usage: /deleteteam <team_name>
    aliases: removeteam, unsetteam
    trigger:
        set {_team} to arg-1
        delete {server::teams::%{_team}%}
        send "&2Delete team: %{_team}%!"

command /teams <text> [<text>]:
    description: Set your teams
    cooldown: 5 seconds
    aliases: team
    usage: /teams <join|leave> <team>
    trigger:
        set {_arg} to arg-1
        set {_team} to arg-2
        if {server::settings::allow_teams} is true:
            if {_arg} is "join":
                delete {server::%uuid of player%::team}
                if {server::teams::%{_team}%} is set:
                    set {server::%uuid of player%::team} to {_team}
                    send "&2You have joined team: &e%{server::%uuid of player%::team}%!"
                else:
                    send "&cThis team doesn't exist!"
            else if {_arg} is "leave":
                delete {server::%uuid of player%::team}
                send "&cYou have left your team!"
        else:
            send "&cYou cannot change teams!"
command /ateam <text> <player> <text>:
    description: The /teams command but as an Admin
    aliases: teamadmin, adminteam
    permission: dc.host.teams.admin
    usage: /ateam <join|leave> <player> <team_name>
    trigger:
        set {_arg1} to arg-1
        set {_arg-2} to arg-2
        set {_arg-3} to arg-3

        if {_arg-1} is "join":
            if {_arg-2} is set:
                if {_arg-3} is set:
                    make {_arg-2} execute command "teams join %{_arg-3}%"
                else:
                    send "&cYou must set a team!"
            else:
                send "&cPlease choose a player!"
        else if {_arg-1} is "leave":
            if {_arg-2} is set:
                if {_arg-3} is set:
                    make {_arg-2} execute command "teams leave %{_arg-3}%"
                else:
                    send "&cYou must set a team!"
            else:
                send "&cPlease choose a player!"

command /allowteams:
    permission: dc.host.teams.allowteams
    description: Allow players to set their team
    aliases: toggleteam, toggleteams
    trigger:
        if {server::settings::allow_teams} is true:
            set {server::settings::allow_teams} to false
        else:
            set {server::settings::allow_teams} to true

        if {server::settings::allow_teams} is true:
            broadcast "&2Teams have been &e&lENABLED"
        else:
            broadcast "&2Teams have been &e&lDISABLED"

function canChat(player: player) :: boolean:
    if {server::%uuid of {_player}%::loggedIn} is "full":
        if {server::%uuid of {_player}%::awaitingPassChange} isn't true:
            if {temp::%uuid of {_player}%::confirmPass} isn't true:
                if {temp::%uuid of {_player}%::awaiting2faSetup} isn't true:
                    if {temp::%uuid of {_player}%::awaiting2faLogin} isn't true:
                        if {temp::%uuid of {_player}%::awaitingPassChange} isn't true:
                            return true
on chat:
    if canChat(player) is true:
        set {_msg} to message
        replace all ":smile:" in {_msg} with "‚ò∫"
        replace all ":frown:" in {_msg} with "‚òπ"
        replace all ":skull:" in {_msg} with "‚ò†"
        replace all ":heart1:" in {_msg} with "‚ù£"
        replace all ":heart:" in {_msg} with "&2‚ù§&f"
        replace all ":peace:" in {_msg} with "‚úå"
        replace all ":pointup:" in {_msg} with "‚òù"
        replace all ":writing:" in {_msg} with "‚úç"
        replace all ":hot:" in {_msg} with "‚ô®"
        replace all ":plane:" in {_msg} with "‚úà"
        replace all ":hourglass:" in {_msg} with "‚åõ"
        replace all ":watch:" in {_msg} with "‚åö"
        replace all ":sun:" in {_msg} with "‚òÄ"
        replace all ":cloud:" in {_msg} with "‚òÅ"
        replace all ":rain:" in {_msg} with "‚òÇ"
        replace all ":snow:" in {_msg} with "‚ùÑ"
        replace all ":bow:" in {_msg} with "üèπ"
        replace all ":shield:" in {_msg} with "üõ°Ô∏è"
        replace all ":dollar:" in {_msg} with "ÔºÑ"
        replace all ":snowman:" in {_msg} with "‚òÉ"
        replace all ":comet:" in {_msg} with "‚òÑ"
        replace all ":spade:" in {_msg} with "‚ô†"
        replace all ":heart2:" in {_msg} with "‚ô•"
        replace all ":diamond:" in {_msg} with "‚ô¶"
        replace all ":club:" in {_msg} with "‚ô£"
        replace all ":pawn:" in {_msg} with "‚ôü"
        replace all ":phone:" in {_msg} with "‚òé"
        replace all ":keyboard:" in {_msg} with "‚å®"
        replace all ":mail:" in {_msg} with "‚úâ"
        replace all ":pencil:" in {_msg} with "‚úè"
        replace all ":fountain:" in {_msg} with "‚úí"
        replace all ":scissors:" in {_msg} with "‚úÇ"
        replace all ":radioactive:" in {_msg} with "‚ò¢"
        replace all ":biohazard:" in {_msg} with "‚ò£"
        replace all ":up:" in {_msg} with "‚¨Ü"
        replace all ":down:" in {_msg} with "‚¨á"
        replace all ":right:" in {_msg} with "‚û°"
        replace all ":left:" in {_msg} with "‚¨Ö"
        replace all ":up_right:" in {_msg} with "‚Üó"
        replace all ":down_right:" in {_msg} with "‚Üò"
        replace all ":down_left:" in {_msg} with "‚Üô"
        replace all ":up_left:" in {_msg} with "‚Üñ"
        replace all ":vert:" in {_msg} with "‚Üï"
        replace all ":hor:" in {_msg} with "‚Üî"
        replace all ":left_return:" in {_msg} with "‚Ü©"
        replace all ":right_return:" in {_msg} with "‚Ü™"
        replace all ":starofdavid:" in {_msg} with "‚ú°"
        replace all ":wheel:" in {_msg} with "‚ò∏"
        replace all ":yin:" in {_msg} with "‚òØ"
        replace all ":cross:" in {_msg} with "‚úù"
        replace all ":orthodox:" in {_msg} with "‚ò¶"
        replace all ":starandcrescent:" in {_msg} with "‚ò™"
        replace all ":peace_sign:" in {_msg} with "‚òÆ"
        replace all ":aries:" in {_msg} with "‚ôà"
        replace all ":taurus:" in {_msg} with "‚ôâ"
        replace all ":gemini:" in {_msg} with "‚ôä"
        replace all ":cancer:" in {_msg} with "‚ôã"
        replace all ":leo:" in {_msg} with "‚ôå"
        replace all ":virgo:" in {_msg} with "‚ôç"
        replace all ":libra:" in {_msg} with "‚ôé"
        replace all ":scorpio:" in {_msg} with "‚ôè"
        replace all ":sagittarius:" in {_msg} with "‚ôê"
        replace all ":capricorn:" in {_msg} with "‚ôë"
        replace all ":aquarius:" in {_msg} with "‚ôí"
        replace all ":pisces:" in {_msg} with "‚ôì"
        replace all ":play:" in {_msg} with "‚ñ∂"
        replace all ":back:" in {_msg} with "‚óÄ"
        replace all ":female:" in {_msg} with "‚ôÄ"
        replace all ":male:" in {_msg} with "‚ôÇ"
        replace all ":x_mark:" in {_msg} with "‚úñ"
        replace all ":double_exclaim:" in {_msg} with "‚Äº"
        replace all ":wave:" in {_msg} with "„Ä∞"
        replace all ":check_box:" in {_msg} with "‚òë"
        replace all ":check:" in {_msg} with "‚úî"
        replace all ":eight_point_star:" in {_msg} with "‚ú≥"
        replace all ":four_point_star:" in {_msg} with "‚ú¥"
        replace all ":sparkle:" in {_msg} with "‚ùá"
        replace all ":copyright:" in {_msg} with "¬©"
        replace all ":registered:" in {_msg} with "¬Æ"
        replace all ":trademark:" in {_msg} with "‚Ñ¢"
        replace all ":circled_m:" in {_msg} with "‚ìÇ"
        replace all ":congratulations:" in {_msg} with "„äó"
        replace all ":secret:" in {_msg} with "„äô"
        replace all ":small_square:" in {_msg} with "‚ñ™"
        replace all ":empty_square:" in {_msg} with "‚ñ´"
        replace all ":heaven:" in {_msg} with "‚ò∑"
        replace all ":water:" in {_msg} with "‚òµ"
        replace all ":earth:" in {_msg} with "‚ò∂"
        replace all ":wind:" in {_msg} with "‚òã"
        replace all ":asc_node:" in {_msg} with "‚òå"
        replace all ":rook:" in {_msg} with "‚ôú"
        replace all ":queen:" in {_msg} with "‚ôï"
        replace all ":heart3:" in {_msg} with "‚ô°"
        replace all ":music:" in {_msg} with "‚ô¨"
        replace all ":backhand:" in {_msg} with "‚òö"
        replace all ":natural:" in {_msg} with "‚ôÆ"
        replace all ":bishop:" in {_msg} with "‚ôù"
        replace all ":sharp:" in {_msg} with "‚ôØ"
        replace all ":fire_element:" in {_msg} with "‚ò¥"
        replace all ":flat:" in {_msg} with "‚ô≠"
        replace all ":cross2:" in {_msg} with "‚òì"
        replace all ":pointing_right:" in {_msg} with "‚òõ"
        replace all ":hammer:" in {_msg} with "‚ò≠"
        replace all ":diamond2:" in {_msg} with "‚ô¢"
        replace all ":pen:" in {_msg} with "‚úê"
        replace all ":castle_rook:" in {_msg} with "‚ôñ"
        replace all ":thunder:" in {_msg} with "‚òà"
        replace all ":cross_box:" in {_msg} with "‚òí"
        replace all ":star:" in {_msg} with "‚òÖ"
        replace all ":king:" in {_msg} with "‚ôö"
        replace all ":queen2:" in {_msg} with "‚ôõ"
        replace all ":pencil2:" in {_msg} with "‚úé"
        replace all ":note:" in {_msg} with "‚ô™"
        replace all ":menu:" in {_msg} with "‚ò∞"
        replace all ":moon:" in {_msg} with "‚òΩ"
        replace all ":caution:" in {_msg} with "‚ò°"
        replace all ":sun2:" in {_msg} with "‚òº"
        replace all ":uranus:" in {_msg} with "‚ôÖ"
        replace all ":empty_box:" in {_msg} with "‚òê"
        replace all ":point_down:" in {_msg} with "‚òü"
        replace all ":flower:" in {_msg} with "‚ù¶"
        replace all ":horn:" in {_msg} with "‚òä"
        replace all ":opposition:" in {_msg} with "‚òç"
        replace all ":vishnu:" in {_msg} with "‚ò¨"
        replace all ":seven:" in {_msg} with "7"
        replace all ":clover:" in {_msg} with "‚ôß"
        replace all ":hexagram:" in {_msg} with "‚ò´"
        replace all ":trigram_sky:" in {_msg} with "‚ò±"
        replace all ":moon2:" in {_msg} with "‚òæ"
        replace all ":staff:" in {_msg} with "‚ò§"
        replace all ":leaf:" in {_msg} with "‚ùß"
        replace all ":saturn:" in {_msg} with "‚ôÑ"
        replace all ":earth2:" in {_msg} with "‚ôÅ"
        replace all ":king2:" in {_msg} with "‚ôî"
        replace all ":heart4:" in {_msg} with "‚ù•"
        replace all ":ankh:" in {_msg} with "‚ò•"
        replace all ":smiley2:" in {_msg} with "‚òª"
        replace all ":spade2:" in {_msg} with "‚ô§"
        replace all ":knight:" in {_msg} with "‚ôû"
        replace all ":neptune:" in {_msg} with "‚ôÜ"
        replace all ":hash:" in {_msg} with "#"
        replace all ":jupiter:" in {_msg} with "‚ôÉ"
        replace all ":quarter_note:" in {_msg} with "‚ô©"
        replace all ":lightning:" in {_msg} with "‚òá"
        replace all ":point_right2:" in {_msg} with "‚òû"
        replace all ":double_note:" in {_msg} with "‚ô´"
        replace all ":phone2:" in {_msg} with "‚òè"
        replace all ":knight2:" in {_msg} with "‚ôò"
        replace all ":cross3:" in {_msg} with "‚òß"
        replace all ":sun3:" in {_msg} with "‚òâ"
        replace all ":pluto:" in {_msg} with "‚ôá"
        replace all ":cross4:" in {_msg} with "‚ò©"
        replace all ":pawn2:" in {_msg} with "‚ôô"
        replace all ":point_left:" in {_msg} with "‚òú"
        replace all ":trigram_fire:" in {_msg} with "‚ò≤"
        replace all ":cross5:" in {_msg} with "‚ò®"
        replace all ":bishop2:" in {_msg} with "‚ôó"
        replace all ":trigram_thunder:" in {_msg} with "‚ò≥"
        replace all ":sword:" in {_msg} with "‚öî"
        replace all ":die1:" in {_msg} with "‚öÄ"
        replace all ":die2:" in {_msg} with "‚öÅ"
        replace all ":die3:" in {_msg} with "‚öÇ"
        replace all ":die4:" in {_msg} with "‚öÉ"
        replace all ":die5:" in {_msg} with "‚öÑ"
        replace all ":die6:" in {_msg} with "‚öÖ"
        replace all ":coffee:" in {_msg} with "‚òï"

        cancel event
        broadcast "%display name of player%: %{_msg}%"
